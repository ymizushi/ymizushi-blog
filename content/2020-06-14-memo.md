---
title: "memo"
date: 2020-06-14T11:47:44+0900
image: 
tags: 
  - 
---


# Box

- データはヒープに格納
- コンパイル時にはサイズを知ることができない型があり、正確なサイズを要求する文脈でその型の値を使用する時
- 多くのデータがあり、所有権を転送したいが、その際にデータがコピーされないようにしたい時
- 値を所有する必要があり、特定の型ではなく特定のトレイトを実装する型であることのみ気にかけている時

# Rc

- ヒープにプログラムの複数箇所で読む何らかのデータを確保したいけれど、 コンパイル時にはどの部分が最後にデータを使用し終わるか決定できない時
- シングルスレッドでしか動作しない
- 単独の値に複数の所有者を持たせたいとき
- Rcでラップした値は不変

# Cell
https://blog.iany.me/2019/02/rust-cell-and-refcell/#:~:text=The%20difference%20is%20how%20they,mutable%20and%20immutable%20reference%20borrowing.

- 所有権の移動を copy もしくは move で解決している
get/set メソッドは値をコピーする（ラップする値が Copy トレイトを実装している必要がある)

take/set は ラップした値をmoveすることで値を取り出すことができる。
move しているので move前の束縛は使用することができない。

Cell は 参照を使って値を取り出すことが出来ない.

# RefCell
- Rc<T>と異なり、RefCell<T>型は、保持するデータに対して単独の所有権を表します。で

RefCell<T>とBox T の違い
参照とBox<T>では、借用規則の不変条件は、コンパイル時に強制されています。RefCell<T>では、 これらの不変条件は、実行時に強制されます。参照でこれらの規則を破ったら、コンパイルエラーになりました。 RefCell<T>でこれらの規則を破ったら、プログラムはパニックし、終了します。

Rcと同様にシングルスレッドで使う前提


- Rc<T>は、同じデータに複数の所有者を持たせてくれる
- Box<T>とRefCell<T>は単独の所有者。
- Box<T>では、不変借用も可変借用もコンパイル時に精査できる
- Rc<T>では不変借用のみがコンパイル時に精査できる
- RefCell<T>では、不変借用も可変借用も実行時に精査される
- RefCell<T>は実行時に精査される可変借用を許可するので、RefCell<T>が不変でも、 RefCell<T>内の値を可変化できる。


method

-- borrow_mut

# 

表にしてみた。
| Rc       |       Right align |    Center align    |
|:-----------------|------------------:|:------------------:|
| This             |              This |        This        |
| column           |            column |       column       |
| will             |              will |        will        |
| be               |                be |         be         |
| left             |             right |       center       |
| aligned          |           aligned |      aligned       |

